[
  {
    "objectID": "whois.html",
    "href": "whois.html",
    "title": "whois ü§ñ",
    "section": "",
    "text": "Machine Learning Scientist ü§ñ\nloves to puzzle üß©\nAmsterdam area üá≥üá±üá™üá∫"
  },
  {
    "objectID": "whois.html#whois",
    "href": "whois.html#whois",
    "title": "whois ü§ñ",
    "section": "",
    "text": "Machine Learning Scientist ü§ñ\nloves to puzzle üß©\nAmsterdam area üá≥üá±üá™üá∫"
  },
  {
    "objectID": "posts/boring_forecast/boring_linear_forecast.html",
    "href": "posts/boring_forecast/boring_linear_forecast.html",
    "title": "Boring linear forecast",
    "section": "",
    "text": "Linear regression in itself is not performant for longer time-scales\nMost systems have some capabilities for linear regression built-in\nAdding dummy variables for datetime features(i.e.¬†month, weekday etc.) adds predictive power"
  },
  {
    "objectID": "posts/boring_forecast/boring_linear_forecast.html#tldr",
    "href": "posts/boring_forecast/boring_linear_forecast.html#tldr",
    "title": "Boring linear forecast",
    "section": "",
    "text": "Linear regression in itself is not performant for longer time-scales\nMost systems have some capabilities for linear regression built-in\nAdding dummy variables for datetime features(i.e.¬†month, weekday etc.) adds predictive power"
  },
  {
    "objectID": "posts/boring_forecast/boring_linear_forecast.html#introduction",
    "href": "posts/boring_forecast/boring_linear_forecast.html#introduction",
    "title": "Boring linear forecast",
    "section": "2 Introduction",
    "text": "2 Introduction\nLinear regression is a statistical model that can be used to determine the linear relationship between variables, most of the time this is seen as a beginners model that is not particularly useful, and most of the time it is discarded and replaced by a shiny neural net or a fancy gradient-boosted model.\nthe nice feature of linear regression is that the direction and magnitude of the relationship can be estimated with the help of linear regression. It is used in many fields including but not limited to Economics, Finance, Social science, etc. The popularity of this model is model is likely due to the fact that most systems have built-in functionality that enables the training of linear models, they are also very cheap/fast to train, and one can also determine that the model has optimal parameters. all these features make linear regression an excellent model to start with.\nTo extend the capabilities of the linear model for time series forecasting, dummy variables can be utilized. These dummies can provide additional information about the relationship over time, can help the model to identify seasonality over time, and also gauge the effect of one-off events, examples are price reductions or natural disasters.\nFor instance, we can create a dummy to identify certain datetime features such as what the month is or whether a particular day is a weekday or a weekend."
  },
  {
    "objectID": "posts/boring_forecast/boring_linear_forecast.html#imports",
    "href": "posts/boring_forecast/boring_linear_forecast.html#imports",
    "title": "Boring linear forecast",
    "section": "3 Imports",
    "text": "3 Imports\nFirst we import all the libraries, the default data science libs and the linear model and metrics from sklearn.\n\n\nCode\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nimport seaborn as sns"
  },
  {
    "objectID": "posts/boring_forecast/boring_linear_forecast.html#reading-in-the-data",
    "href": "posts/boring_forecast/boring_linear_forecast.html#reading-in-the-data",
    "title": "Boring linear forecast",
    "section": "4 Reading in the data",
    "text": "4 Reading in the data\nFor this example, we will be using a dataset form the prophet package. I have selected this one because, in the prophet documentation, this dataset is used in the section ‚ÄúSeasonality, Holiday Effects, And Regressors‚Äù so it seems fitting to use it, to demonstrate the usefulness of seasonal dummies. The prophet docs describes the dataset in the following way:\n\nAs an example, let‚Äôs look at a time series of the log daily page views for the Wikipedia page for Peyton Manning. We scraped this data using the Wikipedia trend package in R. Peyton Manning provides a nice example because it illustrates some of Prophet‚Äôs features, like multiple seasonality, changing growth rates, and the ability to model special days (such as Manning‚Äôs playoff and Superbowl appearances).\n\n\n\nCode\ndf_in = pd.read_csv(\n    \"https://raw.githubusercontent.com/facebook/prophet/main/examples/example_wp_log_peyton_manning.csv\"\n)\ndf_in = df_in.assign(ds=pd.to_datetime(df_in[\"ds\"]))\ndf_in = df_in[(df_in[\"ds\"] &gt; \"2012\")]  # selecting data after 2012\n\n\nIt is always nice to see what we are working with so let us plot the data over time to see what we visually can extract from the plot. we are looking for patterns over time and other behavior and/or pattern that we can exploit.\n\n\nCode\nplt.plot_date(\n    x=df_in[\"ds\"],\n    y=df_in[\"y\"],\n    label=\"input timeseries\",\n    fmt=\"-\",\n)\nplt.tick_params(axis=\"x\", rotation=45)\nplt.ylabel(\"target variable - $y$\")\nplt.title(\"daily visits ot Peyton Manning wiki on a daily basis (log)\")\nplt.show()\n\n\n\n\n\n\n\n\n\nI have selected data from 2012 onwards, this should be enough to test drive the seasonal dummies. The first thing that I notice is that there is a dip around months 06 and 07. In early August teams play so exhibition games before the start of the actual season.\nAlso, we can observe a pattern over the year, it starts high then dips, and then and high again. This can be seen for the other years as well, so there is some repeating seasonality. Let us continue and train our first models. Starting with a simple ordinary linear regression and then adding dummies to see if they improve the performance of the model."
  },
  {
    "objectID": "posts/boring_forecast/boring_linear_forecast.html#train-test-split",
    "href": "posts/boring_forecast/boring_linear_forecast.html#train-test-split",
    "title": "Boring linear forecast",
    "section": "5 Train-test split",
    "text": "5 Train-test split\n\n\nCode\n# train test split\ndf_train = df_in[(df_in[\"ds\"] &gt; \"2012\") & (df_in[\"ds\"] &lt; \"2015\")]\ndf_test = df_in[(df_in[\"ds\"] &gt; \"2015\")]\n\n\nTo gauge the performance of the model the data is split in two parts, the train data from 2012 up to 2015 and the test data everything after 2015. The model will only see the train data and is asked to create a prediction for the test data, after which we will calculate the perfomance with the predictions and the true observations.\n\n\nCode\n# visually inspect the train test split\nplt.plot_date(\n    x=df_train[\"ds\"],\n    y=df_train[\"y\"],\n    label=\"train\",\n    fmt=\"-\",\n)\nplt.plot_date(\n    x=df_test[\"ds\"],\n    y=df_test[\"y\"],\n    label=\"test\",\n    fmt=\"-\",\n)\nplt.legend(loc=\"upper right\")\nplt.tick_params(axis=\"x\", rotation=45)\nplt.ylabel(\"$y$\")\nplt.title(\"data is splitted, everything before 2015 is train data after 2015 test\")\nplt.show()"
  },
  {
    "objectID": "posts/boring_forecast/boring_linear_forecast.html#setting-up-the-regression",
    "href": "posts/boring_forecast/boring_linear_forecast.html#setting-up-the-regression",
    "title": "Boring linear forecast",
    "section": "6 Setting up the regression",
    "text": "6 Setting up the regression\n\n\nCode\nX_train = df_train[\"ds\"].astype(int).to_numpy().reshape(-1, 1)\ny_train = df_train[\"y\"].to_numpy()\n\nX_test = df_test[\"ds\"].astype(int).to_numpy().reshape(-1, 1)\ny_test = df_test[\"y\"].to_numpy()\n\n\nShaping and converting the data so that we can fit the linear model. In this case, we are converting the date columns into an ever-increasing integer.\n\n\nCode\n# creating, fit, and inference\nlinear = LinearRegression()\nlinear.fit(X=X_train, y=y_train)\ny_pred = linear.predict(X=X_test)\n\n\nFitting the linear model is very fast, around 4 milliseconds on my machine, and yes, I know the data volume is low(actually for time series it is pretty decent), but this allows me to fit 1000 models in 4 seconds. So, we can make predictions on 1000 different time series, all in the time it takes to take a sip of coffee‚òïÔ∏è.\nAnyways lets us visually inspect the results of the model, by plotting all the components (train, test, predictions) that we have gathered. Also, let us calculate two error metrics mse and mae that way we can quantify the performance of the model.\n\n\nCode\n# calc error metrics\nmse = mean_squared_error(y_test, y_pred)\nmae = mean_absolute_error(y_test, y_pred)\n\n# visually inspect the prediction\nplt.plot_date(\n    x=df_train[\"ds\"],\n    y=df_train[\"y\"],\n    label=\"train\",\n    fmt=\"-\",\n)\nplt.plot_date(\n    x=df_test[\"ds\"],\n    y=df_test[\"y\"],\n    label=\"test\",\n    fmt=\"-\",\n)\n\nplt.plot_date(\n    x=df_test[\"ds\"],\n    y=y_pred,\n    label=\"prediction\",\n    fmt=\"--\",\n)\n\nplt.legend(loc=\"upper right\")\nplt.tick_params(axis=\"x\", rotation=45)\nplt.ylabel(\"$y$\")\nplt.title(f\"linear regression applied (MSE= {mse:.3}, MAE={mae:.3})\")\nplt.show()\n\n\n\n\n\n\n\n\n\nThe model is just a boring straight line, but what did you expect with a linear model ?! The green line is passing through the orange blob more or less, and intuitively it kind of moves in the right direction. However, it doesn‚Äôt capture the seasonality or other patterns of the train set. The two error metrics mse and mae are both around 0.6. this in itself does not say much, but we can use this as the ‚Äòbenchmark‚Äô and try to improve on this with the addition of the dummies.\n\n\nmean squared error  = 0.617\nmean absolute error = 0.615"
  },
  {
    "objectID": "posts/boring_forecast/boring_linear_forecast.html#adding-dummies",
    "href": "posts/boring_forecast/boring_linear_forecast.html#adding-dummies",
    "title": "Boring linear forecast",
    "section": "7 Adding dummies",
    "text": "7 Adding dummies\nLet us add some dummies for the months and see if we can improve the performance of the model visually and on the metrics. For each month we create a column that can either have the value of 0 or 1. if the value is 1 then that row corresponds to that particular month, in this way we are actively encoding this knowledge into the model. in this way the model can learn the magnitude and direction of each month and apply that to future predictions. at least that is the idea, let us test that!\n\n\nCode\n# creating dummies for the months\ndf_dummies = df_in.assign(\n    month=df_in[\"ds\"].dt.month.astype(\"category\"),\n    ds_int=df_in[\"ds\"].astype(int),\n)\n\nnot_dummy = {\"y\", \"ds\", \"ds_int\"}\nto_dummy = list(set(df_dummies.columns) - not_dummy)\n\ndf_dummies = pd.get_dummies(data=df_dummies, columns=to_dummy)\nall_features = list(set(df_dummies.columns) - {\"y\", \"ds\"})\n\n# slicing the input in train test\ndf_train_dummies = df_dummies[(df_dummies[\"ds\"] &gt; \"2012\") & (df_dummies[\"ds\"] &lt; \"2015\")]\ndf_test_dummies = df_dummies[(df_dummies[\"ds\"] &gt; \"2015\")]\n\nX_train = df_train_dummies.loc[:, all_features]\ny_train = df_train_dummies[[\"y\"]]\n\nX_test = df_test_dummies.loc[:, all_features]\ny_test = df_test_dummies[[\"y\"]]\n\ndf_dummies.drop(columns=[\"ds_int\", \"y\"]).sample(\n    n=6,\n    ignore_index=True,\n    random_state=42,\n)\n\n\n\n\n\n\n\n\n\n\nds\nmonth_1\nmonth_2\nmonth_3\nmonth_4\nmonth_5\nmonth_6\nmonth_7\nmonth_8\nmonth_9\nmonth_10\nmonth_11\nmonth_12\n\n\n\n\n0\n2014-05-06\nFalse\nFalse\nFalse\nFalse\nTrue\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\n\n\n1\n2012-07-05\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nTrue\nFalse\nFalse\nFalse\nFalse\nFalse\n\n\n2\n2015-06-21\nFalse\nFalse\nFalse\nFalse\nFalse\nTrue\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\n\n\n3\n2012-03-09\nFalse\nFalse\nTrue\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\n\n\n4\n2012-08-10\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nTrue\nFalse\nFalse\nFalse\nFalse\n\n\n5\n2013-05-11\nFalse\nFalse\nFalse\nFalse\nTrue\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\n\n\n\n\n\n\n\n\nIn the code block above we are adding the dummies for the month to the data. In this case month_1 is jan and month_12 is dec.\nNext up we are training the model with the added dummies and plotting the results next to the model without the dummies.\n\n\nCode\n# create the pipeline and fit pipeline\n# scaler is there so that the coefs can be interpeted later\n# pipeline = make_pipeline(StandardScaler(), LinearRegression())\npipeline = make_pipeline(MinMaxScaler(), LinearRegression())\n\npipeline.fit(X=X_train, y=y_train)\ny_pred_dummies = pipeline.predict(X=X_test)\n\nmse_dummies = mean_squared_error(y_test, y_pred_dummies)\nmae_dummies = mean_absolute_error(y_test, y_pred_dummies)\n\nplt.plot_date(\n    x=df_train[\"ds\"],\n    y=df_train[\"y\"],\n    label=\"train\",\n    fmt=\"-\",\n)\n\nplt.plot_date(\n    x=df_test[\"ds\"],\n    y=df_test[\"y\"],\n    label=\"test\",\n    fmt=\"-\",\n)\n\nplt.plot_date(\n    x=df_test[\"ds\"],\n    y=y_pred,\n    label=\"prediction\",\n    fmt=\"--\",\n)\n\nplt.plot_date(\n    x=df_test[\"ds\"],\n    y=y_pred_dummies,\n    label=\"prediction with dummies\",\n    fmt=\"--\",\n)\n\nplt.legend(loc=\"upper right\")\nplt.tick_params(axis=\"x\", rotation=45)\nplt.ylabel(\"$y$\")\nplt.title(\n    f\"linear regression with dummies applied (mse= {mse_dummies:.3}, mae={mae_dummies:.3})\"\n)\nplt.show()\n\n\n\n\n\n\n\n\n\nVisually the forecast already looks a lot better. It follows the peaks and valleys of the time-series, and it captures the overall trend better. this is also reflected when we look at the error metrics and the improvement factor that we have achieved. the mean squared error improved with a factor of 1.89 and the mean absolute error improved with a factor of 1.54. That is impressive for just adding a bunch of ones and zeros.\n\n\nCode\nprint(f\"mean squared error  = {mse_dummies:.3}\")\nprint(f\"improvement factor mse month dummies -&gt; {mse/mse_dummies:.3}x\")\n\nprint(\"-\" * 79)\n\nprint(f\"mean absolute error = {mae_dummies:.3}\")\nprint(f\"improvement factor mea month dummies -&gt; {mae/mae_dummies:.3}x\")\n\n\nmean squared error  = 0.325\nimprovement factor mse month dummies -&gt; 1.9x\n-------------------------------------------------------------------------------\nmean absolute error = 0.4\nimprovement factor mea month dummies -&gt; 1.54x"
  },
  {
    "objectID": "posts/boring_forecast/boring_linear_forecast.html#inspecting-the-seasonality",
    "href": "posts/boring_forecast/boring_linear_forecast.html#inspecting-the-seasonality",
    "title": "Boring linear forecast",
    "section": "8 Inspecting the seasonality",
    "text": "8 Inspecting the seasonality\nNow that we have encoded the information about the seasonality in the model, this also allows us to inspect that seasonality by itself. this would give us some insight into the inner workings of the underlying time series model. first we access the coefficients of the linear model and put them into a separate dataframe. then we need to scale them so that the relative difference is more apparent. looking at the raw coefficients would not yield any information as the scale is not relatable to the original problem.\n\n\nCode\n# pull coefs into a seperate df, to inspect the seasonality\nlin_reg_coefs = (\n    pd.DataFrame(\n        data=pipeline[\"linearregression\"].coef_,\n        columns=X_train.columns,\n    )\n    .T.reset_index()\n    .rename(columns={\"index\": \"month\", 0: \"coefficient\"})\n)\n# exclude the time col\nlin_reg_coefs = lin_reg_coefs[lin_reg_coefs[\"month\"] != \"ds_int\"]\n\n# subtract mean to get the relative difference between the coefs\nlin_reg_coefs[\"coefficient\"] = (\n    lin_reg_coefs[\"coefficient\"] - lin_reg_coefs[\"coefficient\"].mean()\n)\n\n\n\n\nCode\nchart = sns.barplot(\n    data=lin_reg_coefs,\n    x=\"month\",\n    y=\"coefficient\",\n    color=sns.color_palette()[0],\n    order=[f\"month_{i}\" for i in range(1, 13)],\n)\nplt.tick_params(axis=\"x\", rotation=45)\nplt.ylabel(\"\")\nplt.title(\"yearly seasonality\")\nplt.show()\n\n\n\n\n\n\n\n\n\nNow we have a beautiful overview of the seasonality over the year. we can clearly see a dip in the middle of the year and a significant uptick in the month of January. in the first week of February, the super bowl is played which is a major factor in the traffic to the wiki page. Also, we noticed that there was a dip in the middle of the year which we can also clearly see at the month_6 mark."
  },
  {
    "objectID": "posts/boring_forecast/boring_linear_forecast.html#recap",
    "href": "posts/boring_forecast/boring_linear_forecast.html#recap",
    "title": "Boring linear forecast",
    "section": "9 Recap",
    "text": "9 Recap\nIn this blog post I have demonstrated that the performance of a simple linear regression for time series forecasting can be improved by a factor of 1.54 up to 1.89 by simply adding dummy variables for the months. the nice thing about this is that the linear regression is available in most systems that have some kind of analytical capability (yes even in excel) and adding the dummies is so simple that you can even do it in a SQL server, the added benefit of this all is that the fitting of the model is quick, therefore you can retrain the model monthly üòâ, weekly, daily, hourly."
  },
  {
    "objectID": "posts/boring_forecast/boring_linear_forecast.html#encore",
    "href": "posts/boring_forecast/boring_linear_forecast.html#encore",
    "title": "Boring linear forecast",
    "section": "10 Encore",
    "text": "10 Encore\nWhat if we were to dummies not just for the months, but also for other datetime features and really turn it up to eleven\n\nLet us create dummies for the following datetime features:\n\nmonth\nweek\ndayofweek\nis_weekend\nquarter\n\nwhen converting this to dummies it will result in a tremendous number of extra features and therefore we will apply a Elasticnet linear model. Usually, this type of model can handle lots of features better than an ordinary linear regression because of the regularization, this will be left as an exercise for the reader.\n\n\nCode\n# creating dummies for the months\ndf_dummies_all = df_in.assign(\n    month=df_in[\"ds\"].dt.month.astype(\"category\"),\n    week=df_in[\"ds\"].dt.isocalendar().week.astype(\"category\"),\n    dayofweek=df_in[\"ds\"].dt.dayofweek.astype(\"category\"),\n    is_weekend=(df_in[\"ds\"].dt.dayofweek) &gt;= 5,\n    quarter=df_in[\"ds\"].dt.quarter.astype(\"category\"),\n    ds_int=df_in[\"ds\"].astype(int),\n)\n\nnot_dummy = {\"y\", \"ds\", \"ds_int\"}\nto_dummy = list(set(df_dummies_all.columns) - not_dummy)\n\ndf_dummies_all = pd.get_dummies(\n    data=df_dummies_all,\n    columns=to_dummy,\n    drop_first=True,  # reduce the amount of cols with no additional info\n)\nall_features = list(set(df_dummies_all.columns) - {\"y\", \"ds\"})\n\n# slicing the input in train test\ndf_train_dummies_all = df_dummies_all[\n    (df_dummies_all[\"ds\"] &gt; \"2012\") & (df_dummies_all[\"ds\"] &lt; \"2015\")\n]\ndf_test_dummies_all = df_dummies_all[(df_dummies_all[\"ds\"] &gt; \"2015\")]\n\nX_train = df_train_dummies_all.loc[:, all_features]\ny_train = df_train_dummies_all[[\"y\"]]\n\nX_test = df_test_dummies_all.loc[:, all_features]\ny_test = df_test_dummies_all[[\"y\"]]\n\ndf_dummies_all.drop(columns=[\"ds_int\", \"y\"]).sample(\n    n=6,\n    ignore_index=True,\n    random_state=42,\n)\n\n\n\n\n\n\n\n\n\n\nds\nweek_2\nweek_3\nweek_4\nweek_5\nweek_6\nweek_7\nweek_8\nweek_9\nweek_10\n...\nmonth_9\nmonth_10\nmonth_11\nmonth_12\ndayofweek_1\ndayofweek_2\ndayofweek_3\ndayofweek_4\ndayofweek_5\ndayofweek_6\n\n\n\n\n0\n2014-05-06\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\n...\nFalse\nFalse\nFalse\nFalse\nTrue\nFalse\nFalse\nFalse\nFalse\nFalse\n\n\n1\n2012-07-05\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\n...\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nTrue\nFalse\nFalse\nFalse\n\n\n2\n2015-06-21\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\n...\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nTrue\n\n\n3\n2012-03-09\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nTrue\n...\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nTrue\nFalse\nFalse\n\n\n4\n2012-08-10\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\n...\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nTrue\nFalse\nFalse\n\n\n5\n2013-05-11\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\n...\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nTrue\nFalse\n\n\n\n\n6 rows √ó 74 columns\n\n\n\n\n\n\nCode\n# utilzing an elasticnet linear model to compensate for the amount of features\nelastic_params = {\n    \"l1_ratio\": np.linspace(start=0.000001, stop=1, num=100),\n    \"cv\": 7,\n    \"n_alphas\": 1_00,\n    \"n_jobs\": -1,\n}\n\npipeline_all = make_pipeline(MinMaxScaler(), ElasticNetCV(**elastic_params))\n\npipeline_all.fit(X=X_train, y=y_train.to_numpy().ravel())\ny_pred_dummies_all = pipeline_all.predict(X=X_test)\n\nmse_dummies_all = mean_squared_error(y_test, y_pred_dummies_all)\nmae_dummies_all = mean_absolute_error(y_test, y_pred_dummies_all)\n\nplt.plot_date(\n    x=df_test[\"ds\"],\n    y=df_test[\"y\"],\n    label=\"test\",\n    fmt=\"-\",\n    alpha=0.7,\n)\n\nplt.plot_date(\n    x=df_test[\"ds\"],\n    y=y_pred_dummies,\n    label=\"prediction with dummies\",\n    fmt=\"--\",\n)\n\nplt.plot_date(\n    x=df_test[\"ds\"],\n    y=y_pred_dummies_all,\n    label=\"prediction with all dummies\",\n    fmt=\"--\",\n)\n\n\nplt.legend(loc=\"upper right\")\nplt.tick_params(axis=\"x\", rotation=45)\nplt.ylabel(\"$y$\")\nplt.title(\n    f\"linear regression with dummies applied (mse= {mse_dummies_all:.3}, mae={mae_dummies_all:.3})\"\n)\nplt.show()\n\n\n\n\n\n\n\n\n\nImmediately it becomes obvious that the model captures more of the fine-grained movement of the time series. this is also reflected in the fact that both error metrics have improved.\n\n\nCode\nprint(f\"mean squared error = {mse_dummies_all:.3}\")\nprint(f\"improvement factor mse month dummies -&gt; {mse/mse_dummies:.3}x\")\nprint(f\"improvement factor mse all dummies   -&gt; {mse/mse_dummies_all:.3}x\")\nprint(\"-\" * 79)\n\nprint(f\"mean absolute error = {mae_dummies_all:.3}\")\nprint(f\"improvement factor mea month dummies -&gt; {mae/mae_dummies:.3}x\")\nprint(f\"improvement factor mea all dummies   -&gt; {mae/mae_dummies_all:.3}x\")\n\n\nmean squared error = 0.262\nimprovement factor mse month dummies -&gt; 1.9x\nimprovement factor mse all dummies   -&gt; 2.35x\n-------------------------------------------------------------------------------\nmean absolute error = 0.356\nimprovement factor mea month dummies -&gt; 1.54x\nimprovement factor mea all dummies   -&gt; 1.73x"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "hyper-shotgun",
    "section": "",
    "text": "Cluster\n\n\ntogether\n\n\n \n\n\n\n\n\n2024-01-17\n\n\nJoost de Theije + LLM\n\n\n9 min\n\n\n\n\n\n\n\n\n\n\n\n\nBoring linear forecast\n\n\nimproving performance by adding some dummies\n\n\n \n\n\n\n\n\n2023-03-5\n\n\nJoost de Theije\n\n\n8 min\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/cluster/cluster.html",
    "href": "posts/cluster/cluster.html",
    "title": "Cluster",
    "section": "",
    "text": "Unsupervised Learning -&gt; Clustering algorithms are used for unsupervised learning, ideal for exploratory data analysis.\nGrouping Data -&gt; These algorithms group similar data into clusters based on specific criteria.\nVariety of Applications -&gt; They‚Äôre used in diverse fields like customer segmentation, anomaly detection, and more.\nDifferent Techniques -&gt; Various types exist, like K-means and DBSCAN, each with unique strengths and suited for specific data types.\nChoice of Parameters -&gt; The selection and tuning of parameters, like the number of clusters, significantly influence the results.\n\nIn the vast field of machine learning, clustering algorithms hold a pivotal role. Used as a form of unsupervised learning, they uncover hidden patterns and structures within unlabeled data, making them instrumental for exploratory data analysis. The essence of clustering algorithms lies in their ability to sift through unstructured data and bring together similar items, forming distinct groups or ‚Äòclusters‚Äô based on defined criteria.\nThese algorithms have found their place in a myriad of real-world applications. From customer segmentation in marketing strategies, to image segmentation in computer vision, anomaly detection in cybersecurity, and dimensionality reduction in high-dimensional data‚Äîclustering algorithms are at the heart of insightful data-driven decision making.\nThe world of clustering algorithms is diverse, housing various types such as K-means, hierarchical, DBSCAN, and Gaussian Mixture Models, each coming with its unique strengths, limitations, and suitability for certain types of data.\nA crucial aspect of working with these algorithms is the specification of parameters. While some algorithms like K-means require the user to define the number of clusters in advance, others, like DBSCAN, determine the number of clusters based on the data itself. The choice and tuning of these parameters can significantly steer the algorithm‚Äôs effectiveness, making this a critical skill for any data practitioner.\nIn this blog post, we delve deeper into the intriguing world of clustering algorithms, demystifying their workings, exploring their varieties, and discussing how to choose and fine-tune parameters for optimal results. Stay tuned as we embark on this insightful journey.\n\n\n\na lovely shopping mall\n\n\nPhoto by Sung Jin Cho on Unsplash"
  },
  {
    "objectID": "posts/cluster/cluster.html#tldr",
    "href": "posts/cluster/cluster.html#tldr",
    "title": "Cluster",
    "section": "",
    "text": "Unsupervised Learning -&gt; Clustering algorithms are used for unsupervised learning, ideal for exploratory data analysis.\nGrouping Data -&gt; These algorithms group similar data into clusters based on specific criteria.\nVariety of Applications -&gt; They‚Äôre used in diverse fields like customer segmentation, anomaly detection, and more.\nDifferent Techniques -&gt; Various types exist, like K-means and DBSCAN, each with unique strengths and suited for specific data types.\nChoice of Parameters -&gt; The selection and tuning of parameters, like the number of clusters, significantly influence the results.\n\nIn the vast field of machine learning, clustering algorithms hold a pivotal role. Used as a form of unsupervised learning, they uncover hidden patterns and structures within unlabeled data, making them instrumental for exploratory data analysis. The essence of clustering algorithms lies in their ability to sift through unstructured data and bring together similar items, forming distinct groups or ‚Äòclusters‚Äô based on defined criteria.\nThese algorithms have found their place in a myriad of real-world applications. From customer segmentation in marketing strategies, to image segmentation in computer vision, anomaly detection in cybersecurity, and dimensionality reduction in high-dimensional data‚Äîclustering algorithms are at the heart of insightful data-driven decision making.\nThe world of clustering algorithms is diverse, housing various types such as K-means, hierarchical, DBSCAN, and Gaussian Mixture Models, each coming with its unique strengths, limitations, and suitability for certain types of data.\nA crucial aspect of working with these algorithms is the specification of parameters. While some algorithms like K-means require the user to define the number of clusters in advance, others, like DBSCAN, determine the number of clusters based on the data itself. The choice and tuning of these parameters can significantly steer the algorithm‚Äôs effectiveness, making this a critical skill for any data practitioner.\nIn this blog post, we delve deeper into the intriguing world of clustering algorithms, demystifying their workings, exploring their varieties, and discussing how to choose and fine-tune parameters for optimal results. Stay tuned as we embark on this insightful journey.\n\n\n\na lovely shopping mall\n\n\nPhoto by Sung Jin Cho on Unsplash"
  },
  {
    "objectID": "posts/cluster/cluster.html#data-preprocessing",
    "href": "posts/cluster/cluster.html#data-preprocessing",
    "title": "Cluster",
    "section": "2 Data Preprocessing",
    "text": "2 Data Preprocessing\nIn this initial stage, the goal is to prepare the data for analysis. This involves cleaning the data by removing or filling in missing values, which could be done through various strategies like dropping the missing rows, filling them with mean/median/mode, or using a prediction model. It‚Äôs also crucial to handle outliers and potentially normalize features if they‚Äôre on different scales. This stage might also involve dealing with categorical variables using encoding techniques. Effective preprocessing is crucial for reliable results in the subsequent stages.\ndataset can be found here\n\n\n\n\n\n\n\nField\nDescription\n\n\n\n\nCustomerID\nUnique ID assigned to the customer\n\n\nGender\nGender of the customer\n\n\nAge\nAge of the customer\n\n\nAnnual Income (k$)\nAnnual income of the customer\n\n\nSpending Score (1-100)\nScore assigned by the mall based on customer behavior and spending nature\n\n\n\n\n\nCode\n# imports\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nimport seaborn as sns\nimport umap\nfrom matplotlib_inline.backend_inline import set_matplotlib_formats\nfrom sklearn.cluster import KMeans\nfrom sklearn.decomposition import PCA\nfrom sklearn.preprocessing import power_transform\nfrom yellowbrick.cluster import kelbow_visualizer, silhouette_visualizer\n\n# setting global plotting settings\nset_matplotlib_formats(\"svg\")\nsns.set_palette(\"tab10\")\nsns.set_style(\"darkgrid\")\nFIGSIZE = (12, 6)\n\n\n/opt/homebrew/Caskroom/miniconda/base/envs/hypershotgun/lib/python3.10/site-packages/tqdm/auto.py:21: TqdmWarning: IProgress not found. Please update jupyter and ipywidgets. See https://ipywidgets.readthedocs.io/en/stable/user_install.html\n  from .autonotebook import tqdm as notebook_tqdm\n\n\n\n\nCode\n# Load the customer dataset to analyze shopping patterns\ndf_mall = pd.read_csv(\"artifacts/Mall_Customers.csv\")\n\n# rename columns to be lowercase, for easy typing\ndf_mall = df_mall.rename(\n    columns={\n        \"CustomerID \": \"id\",\n        \"Gender \": \"gender\",\n        \"Age \": \"age\",\n        \"Annual Income (k$) \": \"income\",\n        \"Spending Score (1-100)\": \"spending\",\n    }\n)\ndf_mall[\"gender\"] = df_mall[\"gender\"].str.lower()\ndf_mall[\"gender\"] = df_mall[\"gender\"].str.strip()\n\n\n# look at a random sample to validate the contents\ndf_mall.sample(6)\n\n\n\n\n\n\n\n\n\n\nid\ngender\nage\nincome\nspending\n\n\n\n\n35\n36\nfemale\n21\n33\n81\n\n\n148\n149\nfemale\n34\n78\n22\n\n\n157\n158\nfemale\n30\n78\n78\n\n\n21\n22\nmale\n25\n24\n73\n\n\n10\n11\nmale\n67\n19\n14\n\n\n8\n9\nmale\n64\n19\n3\n\n\n\n\n\n\n\n\nUpon examination of the dataset, it appears that the ‚Äògender‚Äô column is the only non-numeric feature. Specifically, it contains string values categorizing customers as either ‚ÄúMale‚Äù or ‚ÄúFemale‚Äù. All other columns - ‚Äòid‚Äô, ‚Äòage‚Äô, ‚Äòincome‚Äô, and ‚Äòspending‚Äô - are numeric data types.\nThe ‚Äòid‚Äô column seems to be a unique identifier for each customer. While numeric, this feature has very high cardinality (a distinct value for every customer). Features with high cardinality tend to dominate distance calculations in clustering algorithms and obscure more meaningful patterns in the data. Therefore, we should exclude the customer ID column from the feature set used for clustering.\n\nFor the remaining features to function effectively in clustering algorithms, the input features generally need to be numeric rather than categorical strings. Distance-based algorithms like k-means rely on computing distances between data points across features. String categories do not have an inherent numeric ordering, so the distance computations would not be meaningful.\nAdditionally, when performing exploratory analysis, a numeric encoding often allows easier visualization of the impact of gender relative to the other numeric features. Box plots, scatter plots with color-coded points, and other techniques can provide better insights into how gender correlates with shopper age, income or spending habits when mapped to a numeric form.\n\nTherefore, to enable the application of clustering algorithms and more impactful analysis, we need to process the ‚Äògender‚Äô column by encoding the categories as numbers. Common encoding schemes include mapping ‚ÄúMale‚Äù and ‚ÄúFemale‚Äù to 1 and 0 respectively, or using one-hot encoding to create an additional binary feature column for each category. After encoding, gender will be represented numerically like the other existing features.\nIn summary, as gender is the only non-numeric column, and ID has high cardinality unsuitable for clustering, effectively preparing the data requires encoding the gender categorical data and excluding the customer ID column.\n\n\nCode\ndf_mall.describe().round(1)\n\n\n\n\n\n\n\n\n\n\nid\nage\nincome\nspending\n\n\n\n\ncount\n200.0\n200.0\n200.0\n200.0\n\n\nmean\n100.5\n38.8\n60.6\n50.2\n\n\nstd\n57.9\n14.0\n26.3\n25.8\n\n\nmin\n1.0\n18.0\n15.0\n1.0\n\n\n25%\n50.8\n28.8\n41.5\n34.8\n\n\n50%\n100.5\n36.0\n61.5\n50.0\n\n\n75%\n150.2\n49.0\n78.0\n73.0\n\n\nmax\n200.0\n70.0\n137.0\n99.0\n\n\n\n\n\n\n\n\nThe dataset contains 200 records, for each of the variables - id, age, income, and spending.\nid: This is the unique identifier for each customer. It ranges from 1 to 200 with an average (mean) value of 100.5. The standard deviation is approximately 57.9, indicating that the id values are spread out over a large range.\nage: The average age of the customers in the dataset is 38.8 years. The age ranges from a minimum of 18 years to a maximum of 70 years, with a standard deviation of 14. This suggests that the mall has a diverse age range of customers, and the majority of them are middle-aged.\nincome: The average annual income of the customers is approximately $60.6 thousand. It has a standard deviation of 26.3, indicating a considerable variation in the incomes of the customers. The minimum income is $15 thousand, while the maximum is $137 thousand. This suggests a wide spread of customers from different income levels.\nspending: The average spending score assigned by the mall is about 50.2. The spending score ranges from a minimum of 1 to a maximum of 99, with a standard deviation of 25.8. This suggests a broad spectrum of customer spending behaviors, from low spenders to high spenders.\nThe 25%, 50%, and 75% rows represent the corresponding percentiles for each variable:\nFor age, 25% of the customers are 28.8 years or younger, 50% (which is also the median) are 36 years or younger, and 75% are 49 years or younger. For income, 25% of the customers earn $41.5 thousand or less, 50% earn $61.5 thousand or less, and 75% earn $78 thousand or less. For spending, 25% of the customers have a spending score of 34.8 or less, 50% have a score of 50 or less, and 75% have a score of 73 or less.\n\n\nCode\n# convert gender to a numerical value via one-hot-encoding\n# clustering models usally need numerical values\ndf_mall = pd.get_dummies(df_mall, columns=[\"gender\"], drop_first=True)\n\n# list with features for easy reference\nfeatures = [\"age\", \"income\", \"spending\", \"gender_male\"]\ndf_feature = df_mall[features]\n\n\n# look at a random sample to validate the contents\ndf_feature.sample(5)\n\n\n\n\n\n\n\n\n\n\nage\nincome\nspending\ngender_male\n\n\n\n\n155\n27\n78\n89\nFalse\n\n\n166\n42\n86\n20\nTrue\n\n\n33\n18\n33\n92\nTrue\n\n\n45\n24\n39\n65\nFalse\n\n\n36\n42\n34\n17\nFalse\n\n\n\n\n\n\n\n\n\n\nCode\ndf_feature.info()\n\n\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 200 entries, 0 to 199\nData columns (total 4 columns):\n #   Column       Non-Null Count  Dtype\n---  ------       --------------  -----\n 0   age          200 non-null    int64\n 1   income       200 non-null    int64\n 2   spending     200 non-null    int64\n 3   gender_male  200 non-null    bool \ndtypes: bool(1), int64(3)\nmemory usage: 5.0 KB"
  },
  {
    "objectID": "posts/cluster/cluster.html#exploratory-data-analysis",
    "href": "posts/cluster/cluster.html#exploratory-data-analysis",
    "title": "Cluster",
    "section": "3 Exploratory Data Analysis",
    "text": "3 Exploratory Data Analysis\nVisualize the data and derive initial insights.\n\n\nCode\nprint(df_feature.describe().T)\n\n\n          count   mean        std   min    25%   50%   75%    max\nage       200.0  38.85  13.969007  18.0  28.75  36.0  49.0   70.0\nincome    200.0  60.56  26.264721  15.0  41.50  61.5  78.0  137.0\nspending  200.0  50.20  25.823522   1.0  34.75  50.0  73.0   99.0\n\n\nThe dataset contains information 200 customers. The average (mean) age is 38.85 years. Ages range from 18 to 70, with 50% of customers aged 36 years or below.\nThe average annual income is $60,560, ranging from $15,000 to $137,000. 50% of customers earn $61,500 or less.\nFor the spending score (1-100), the average is 50.2. Half the customers have a spending score of 50 or below. The minimum is 1 and maximum 99, showing a wide range in spending habits.\nOverall, we see variation among customers in age, income levels, and purchasing patterns. Clustering algorithms can help segment customers into groups based on these attributes to develop targeted marketing approaches. let us first look at the distributions of the features.\n\n\nCode\nfig, ax = plt.subplots(1, 2, figsize=FIGSIZE)\n\nsns.countplot(\n    data=df_feature, x=\"gender_male\", stat=\"percent\", hue=\"gender_male\", ax=ax[0]\n)\n\nsns.kdeplot(x=\"age\", data=df_feature, hue=\"gender_male\", ax=ax[1])\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\nCode\nfig, ax = plt.subplots(1, 2, figsize=FIGSIZE)\n\ncurr_ax = ax[0]\nsns.regplot(\n    data=df_feature[df_feature[\"gender_male\"] == 0],\n    x=\"age\",\n    y=\"income\",\n    color=sns.color_palette()[0],\n    order=1,\n    lowess=True,\n    truncate=True,\n    ax=curr_ax,\n)\n\n\ncurr_ax = ax[0]\nsns.regplot(\n    data=df_feature[df_feature[\"gender_male\"] == 1],\n    x=\"age\",\n    y=\"income\",\n    color=sns.color_palette()[1],\n    order=1,\n    lowess=True,\n    truncate=True,\n    ax=curr_ax,\n)\ncurr_ax.legend(\n    [\"gender_male=0\", \"lowess regression\", \"gender_male=1\", \"lowess regression\"]\n)\ncurr_ax.set_title(\"age vs. income\")\n\n\ncurr_ax = ax[1]\nsns.regplot(\n    data=df_feature[df_feature[\"gender_male\"] == 0],\n    x=\"age\",\n    y=\"spending\",\n    color=sns.color_palette()[0],\n    order=1,\n    lowess=True,\n    truncate=True,\n    ax=curr_ax,\n)\n\n\ncurr_ax = ax[1]\nsns.regplot(\n    data=df_feature[df_feature[\"gender_male\"] == 1],\n    x=\"age\",\n    y=\"spending\",\n    color=sns.color_palette()[1],\n    order=1,\n    lowess=True,\n    truncate=True,\n    ax=curr_ax,\n)\ncurr_ax.legend(\n    [\"gender_male=0\", \"lowess regression\", \"gender_male=1\", \"lowess regression\"]\n)\ncurr_ax.set_title(\"age vs. spending\")\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\nCode\nfig, ax = plt.subplots(1, 2, figsize=FIGSIZE)\n\ncurr_ax = ax[0]\nsns.scatterplot(\n    data=df_feature,\n    x=\"income\",\n    y=\"spending\",\n    hue=\"age\",\n    palette=sns.color_palette(\"viridis\", as_cmap=True),\n    # style=\"gender_male\",\n    ax=curr_ax,\n)\n\n\ncurr_ax = ax[1]\nsns.scatterplot(\n    data=df_feature,\n    x=\"income\",\n    y=\"spending\",\n    # hue=\"age\",\n    # palette=sns.color_palette(\"viridis\", 2),\n    hue=\"gender_male\",\n    ax=curr_ax,\n)\n\nplt.suptitle(\"Age vs. Spending\")\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\nCode\n# create a ratio between income and spending\ndf_ratio = df_feature.assign(si_ratio=df_feature[\"income\"] / df_feature[\"spending\"])\n\nfig, ax = plt.subplots(1, 2, figsize=FIGSIZE)\ncurr_ax = ax[0]\n\nsns.scatterplot(\n    data=df_ratio,\n    x=\"si_ratio\",\n    y=\"age\",\n    ax=curr_ax,\n)\n\n\n# clip to 95% quantile of the si ratio,\n# this will zoom into the interesting part of the plot\ndf_ratio = df_ratio.assign(\n    si_ratio_clip=df_ratio[\"si_ratio\"].clip(\n        upper=np.quantile(df_ratio[\"si_ratio\"], 0.95)\n    )\n)\n\ncurr_ax = ax[1]\nsns.scatterplot(\n    data=df_ratio,\n    x=\"si_ratio_clip\",\n    y=\"age\",\n    ax=curr_ax,\n)\n\n\n\n\n\n\n\n\n\n\n\nCode\ndf_ratio = df_ratio.assign(\n    si_ratio_transform=power_transform(\n        df_ratio[\"si_ratio\"].to_numpy().reshape(-1, 1), method=\"yeo-johnson\"\n    )\n)\n\n\n\n\nCode\nfig, ax = plt.subplots(1, 2, figsize=FIGSIZE)\n\nsns.histplot(data=df_ratio[\"si_ratio\"], stat=\"percent\", ax=ax[0])\n\nsns.histplot(\n    data=df_ratio[\"si_ratio_transform\"],\n    stat=\"percent\",\n    ax=ax[1],\n)\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\nCode\ndef calc_umap(\n    df_in: pd.DataFrame,\n    n_neighbors=15,\n    min_dist=0.15,\n    n_components=2,\n):\n    # data structure, with the goal of a 2D representation.\n    reducer = umap.UMAP(\n        n_neighbors=n_neighbors,\n        n_components=n_components,\n        min_dist=min_dist,\n        metric=\"euclidean\",\n        random_state=42,\n        n_jobs=1,  # setting to 1 to lock in the random state\n    )\n\n    # fit the data to the reducer\n    return reducer.fit_transform(df_in)\n\n\ndef plot_umap(embeddings: np.array = None, ax: plt.axes = None):\n    # create the scatter plot of the 2 component embedding\n    # the order of x,y doesnt matter, the relative distance does\n    ax.scatter(x=embeddings[:, 0], y=embeddings[:, 1], s=12, alpha=0.7)\n\n    # remove axis labels and ticks\n    # as these are meaningless for umap\n    ax.set_xticklabels([])\n    ax.set_yticklabels([])\n\n    # n_neighbors are formatted as floats  and min_dist are formatted as int\n    ax.set_title(f\"{n_neighbors=:.0f} {min_dist=:.2f}\")\n\n\n\n\nCode\n# defining the parameter sweep\nrange_min_dist = np.linspace(0, 1, 5)  # min_dist\nrange_n_neighbors = np.arange(10, 14)  # n_neighbors\n\n\n# creating the subplots and performing the embedding with the parameter sweep\nfig, ax = plt.subplots(\n    nrows=len(range_min_dist), ncols=len(range_n_neighbors), figsize=(16, 10)\n)\n\nfor i_min_dist, min_dist in enumerate(range_min_dist):\n    for i_n_neighbors, n_neighbors in enumerate(range_n_neighbors):\n        embeddings = calc_umap(\n            df_in=df_feature,\n            n_neighbors=int(n_neighbors),\n            min_dist=float(min_dist),\n        )\n        plot_umap(embeddings=embeddings, ax=ax[i_min_dist, i_n_neighbors])\n\nfig.supxlabel(\" -&gt; n_neighbors\")\nfig.supylabel(\" -&gt; min_dist\")\nfig.tight_layout()\nplt.show()"
  },
  {
    "objectID": "posts/cluster/cluster.html#feature-engineering",
    "href": "posts/cluster/cluster.html#feature-engineering",
    "title": "Cluster",
    "section": "4 Feature Engineering",
    "text": "4 Feature Engineering\nBased on your EDA, create features that might help define customer segmentation, such as total purchase value, average purchase size, frequency of purchase, etc.\n\ncreate bins for the age bracket\ncalculate descriptive stats for each bracket i.e mean spending size, income\nratio of income of spending\nnormalization of variables -&gt; make comment on the distance calculations\n\n\n\nCode\n# bin the age variable into 7 bins\n# fmt: off\nbinned = pd.cut(\n    df_feature[\"age\"],\n    bins=[0, 20, 30, 40, 50, 60, 70, 80],\n    labels=[1,2,3,4,5,6,7],\n    )\n# fmt: on\ndf_feature = df_feature.assign(age_bin=binned)\ndf_feature.sample(10)\n\n\n\n\n\n\n\n\n\n\nage\nincome\nspending\ngender_male\nage_bin\n\n\n\n\n115\n19\n65\n50\nFalse\n1\n\n\n107\n54\n63\n46\nTrue\n5\n\n\n52\n31\n43\n54\nFalse\n3\n\n\n77\n40\n54\n48\nTrue\n3\n\n\n125\n31\n70\n77\nFalse\n3\n\n\n189\n36\n103\n85\nFalse\n3\n\n\n138\n19\n74\n10\nTrue\n1\n\n\n143\n32\n76\n87\nFalse\n3\n\n\n136\n44\n73\n7\nFalse\n4\n\n\n81\n38\n54\n55\nTrue\n3\n\n\n\n\n\n\n\n\n\n\nCode\n# calculate the ratio between\n# spending and income -&gt; how much of the income do you spend\n# spending and age -&gt; if you are older do you spend more or less\ndf_feature = df_feature.assign(\n    si_ratio=df_feature[\"income\"] / df_feature[\"spending\"],\n    sa_ratio=df_feature[\"age\"] / df_feature[\"spending\"],\n)\ndf_feature.sample(10)\n\n\n\n\n\n\n\n\n\n\nage\nincome\nspending\ngender_male\nage_bin\nsi_ratio\nsa_ratio\n\n\n\n\n8\n64\n19\n3\nTrue\n6\n6.333333\n21.333333\n\n\n57\n69\n44\n46\nTrue\n6\n0.956522\n1.500000\n\n\n62\n67\n47\n52\nFalse\n6\n0.903846\n1.288462\n\n\n100\n23\n62\n41\nFalse\n2\n1.512195\n0.560976\n\n\n134\n20\n73\n5\nTrue\n1\n14.600000\n4.000000\n\n\n60\n70\n46\n56\nTrue\n6\n0.821429\n1.250000\n\n\n45\n24\n39\n65\nFalse\n2\n0.600000\n0.369231\n\n\n16\n35\n21\n35\nFalse\n3\n0.600000\n1.000000\n\n\n155\n27\n78\n89\nFalse\n2\n0.876404\n0.303371\n\n\n21\n25\n24\n73\nTrue\n2\n0.328767\n0.342466\n\n\n\n\n\n\n\n\n\n\nCode\n# turn off the formatter, to increase readability\n# fmt: off\n# create a new column with the difference between income and the mean income of the gender group\ndf_feature = df_feature.assign(\n    # create a new column with the difference between income and the mean income of the gender group\n    income_vs_gender_mean=df_feature['income'] - df_feature.groupby(\"gender_male\",)[[\"income\",]].transform(\"mean\").iloc[:, 0],\n    spending_vs_gender_mean=df_feature[\"spending\"] - df_feature.groupby(\"gender_male\")[[\"spending\",]].transform(\"mean\").iloc[:, 0],\n\n    # create a new column with the difference between income and the mean income of the age group\n    income_vs_age_mean=df_feature[\"income\"] - df_feature.groupby(\"age_bin\",observed=False)[[\"income\",]].transform(\"mean\").iloc[:, 0],\n    spending_vs_age_mean=df_feature[\"spending\"] - df_feature.groupby(\"age_bin\",observed=False)[[\"spending\",]].transform(\"mean\").iloc[:, 0],\n)\n# fmt: on\n\ndf_feature.sample(10)\n\n\n\n\n\n\n\n\n\n\nage\nincome\nspending\ngender_male\nage_bin\nsi_ratio\nsa_ratio\nincome_vs_gender_mean\nspending_vs_gender_mean\nincome_vs_age_mean\nspending_vs_age_mean\n\n\n\n\n125\n31\n70\n77\nFalse\n3\n0.909091\n0.402597\n10.750000\n25.473214\n1.366667\n19.500000\n\n\n107\n54\n63\n46\nTrue\n5\n1.369565\n1.173913\n0.772727\n-2.511364\n6.304348\n13.478261\n\n\n184\n41\n99\n39\nFalse\n4\n2.538462\n1.051282\n39.750000\n-12.526786\n35.394737\n4.605263\n\n\n160\n56\n79\n35\nFalse\n5\n2.257143\n1.600000\n19.750000\n-16.526786\n22.304348\n2.478261\n\n\n191\n32\n103\n69\nFalse\n3\n1.492754\n0.463768\n43.750000\n17.473214\n34.366667\n11.500000\n\n\n75\n26\n54\n54\nTrue\n2\n1.000000\n0.481481\n-8.227273\n5.488636\n-2.755556\n-13.222222\n\n\n156\n37\n78\n1\nTrue\n3\n78.000000\n37.000000\n15.772727\n-47.511364\n9.366667\n-56.500000\n\n\n27\n35\n28\n61\nTrue\n3\n0.459016\n0.573770\n-34.227273\n12.488636\n-40.633333\n3.500000\n\n\n37\n30\n34\n73\nFalse\n2\n0.465753\n0.410959\n-25.250000\n21.473214\n-22.755556\n5.777778\n\n\n78\n23\n54\n52\nFalse\n2\n1.038462\n0.442308\n-5.250000\n0.473214\n-2.755556\n-15.222222\n\n\n\n\n\n\n\n\n\n\nCode\n# apply power transform\n# sns.histplot(df_feature['age'])\nsns.histplot(df_feature[\"income_vs_gender_mean\"])\n# sns.histplot(df_feature['age'])\n# sns.histplot(df_feature['age'])\n# sns.histplot(df_feature['age'])\n\n\n\n\n\n\n\n\n\n\n\nCode\n# casting values to integer in order for scaling later on\ndf_feature = df_feature.assign(\n    age_bin=df_feature[\"age_bin\"].astype(int),\n)\n\ndf_feature[df_feature.select_dtypes(include=\"number\").columns] = power_transform(\n    X=df_feature[df_feature.select_dtypes(include=\"number\").columns],\n    method=\"yeo-johnson\",\n)\ndf_feature.sample(10)\n\n\n\n\n\n\n\n\n\n\nage\nincome\nspending\ngender_male\nage_bin\nsi_ratio\nsa_ratio\nincome_vs_gender_mean\nspending_vs_gender_mean\nincome_vs_age_mean\nspending_vs_age_mean\n\n\n\n\n121\n0.091408\n0.315793\n-0.346103\nFalse\n-0.113303\n0.410752\n0.171627\n0.334914\n-0.448683\n-0.057930\n-0.830815\n\n\n13\n-1.131234\n-1.703543\n1.023549\nFalse\n-0.918216\n-1.981503\n-1.239494\n-1.560981\n0.990713\n-1.456576\n0.348714\n\n\n180\n0.018057\n1.326551\n-0.664338\nFalse\n-0.113303\n1.090172\n0.424146\n1.404470\n-0.759482\n1.116249\n-1.113231\n\n\n137\n-0.376090\n0.528911\n0.881491\nTrue\n-0.113303\n-0.291252\n-0.840743\n0.444649\n0.952382\n0.178255\n0.669853\n\n\n81\n0.091408\n-0.170436\n0.225966\nTrue\n-0.113303\n-0.317090\n-0.250975\n-0.279316\n0.251737\n-0.574370\n-0.265329\n\n\n191\n-0.376090\n1.514638\n0.738221\nFalse\n-0.113303\n0.260205\n-0.770467\n1.615155\n0.679276\n1.350185\n0.444178\n\n\n77\n0.233319\n-0.170436\n-0.037540\nTrue\n-0.113303\n-0.126075\n-0.001269\n-0.279316\n-0.020591\n-0.574370\n-0.537953\n\n\n99\n-1.591912\n0.095898\n0.000449\nTrue\n-1.892399\n0.014376\n-0.928139\n0.000060\n0.018297\n0.394320\n0.057231\n\n\n130\n0.686612\n0.458577\n-1.669978\nTrue\n0.585358\n1.787960\n1.741536\n0.372130\n-1.535716\n0.296935\n-1.109565\n\n\n4\n-0.461118\n-1.872032\n-0.346103\nFalse\n-0.113303\n-1.444914\n-0.097838\n-1.686685\n-0.448683\n-2.050982\n-0.830815\n\n\n\n\n\n\n\n\n\n\nCode\ndf_feature.describe().T\n\n\n\n\n\n\n\n\n\n\ncount\nmean\nstd\nmin\n25%\n50%\n75%\nmax\n\n\n\n\nage\n200.0\n7.016610e-16\n1.002509\n-1.851739\n-0.661494\n-0.056996\n0.805504\n1.852811\n\n\nincome\n200.0\n-5.684342e-16\n1.002509\n-1.989930\n-0.678427\n0.114476\n0.701866\n2.515898\n\n\nspending\n200.0\n3.552714e-17\n1.002509\n-2.100163\n-0.553723\n0.038318\n0.881491\n1.786065\n\n\nage_bin\n200.0\n5.462297e-16\n1.002509\n-1.892399\n-0.918216\n-0.113303\n0.585358\n1.777954\n\n\nsi_ratio\n200.0\n4.263256e-16\n1.002509\n-2.274854\n-0.463817\n-0.124667\n0.335556\n2.253114\n\n\nsa_ratio\n200.0\n-2.575717e-16\n1.002509\n-1.693664\n-0.914656\n0.032022\n0.665247\n2.116408\n\n\nincome_vs_gender_mean\n200.0\n-7.105427e-17\n1.002509\n-1.895689\n-0.729683\n0.076205\n0.633519\n2.695342\n\n\nspending_vs_gender_mean\n200.0\n-5.329071e-17\n1.002509\n-1.846407\n-0.652651\n-0.020890\n0.834990\n1.886854\n\n\nincome_vs_age_mean\n200.0\n-7.105427e-17\n1.002509\n-2.050982\n-0.719487\n0.040759\n0.596834\n3.135560\n\n\nspending_vs_age_mean\n200.0\n-3.108624e-17\n1.002509\n-2.155238\n-0.827041\n0.063810\n0.678319\n2.582476"
  },
  {
    "objectID": "posts/cluster/cluster.html#clustering",
    "href": "posts/cluster/cluster.html#clustering",
    "title": "Cluster",
    "section": "5 Clustering",
    "text": "5 Clustering\nUse a suitable clustering algorithm (like K-means or hierarchical clustering) to divide customers into distinct groups.\n\n\nCode\nfig, ax = plt.subplots(figsize=FIGSIZE)\n\n_ = kelbow_visualizer(\n    KMeans(n_init=10),\n    X=df_feature,\n    timings=False,\n    metric=\"distortion\",\n    ax=ax,\n)  # distortion: mean sum of squared distances to centers\n\n\n\n\n\n\n\n\n\n\n\nCode\n# fit kmeans for various number of clusters\nkmeans_clusters = [\n    KMeans(n_clusters=i, n_init=\"auto\", max_iter=900) for i in range(2, 11)\n]\n\n\n\n\nCode\nfig, axes = plt.subplots(3, 3, figsize=(18, 16), layout=\"constrained\")\n\nfor i, ax in enumerate(axes.flatten()):\n    silhouette_visualizer(\n        kmeans_clusters[i],\n        X=df_feature,\n        ax=ax,\n        is_fitted=False,\n        show=False,\n        colors=sns.color_palette(\"tab10\"),\n    )\nplt.tight_layout()\nplt.show()\n\n\n/var/folders/q6/pntlsv6s1j19xm8fhz9g32fr0000gn/T/ipykernel_28168/1231921934.py:12: UserWarning: The figure layout has changed to tight\n  plt.tight_layout()\n\n\n\n\n\n\n\n\n\n\n\nCode\ndecomp = PCA(n_components=2)\ndecomp_components = decomp.fit_transform(df_feature)\n\n\nfig, ax = plt.subplots(figsize=FIGSIZE)\nsns.scatterplot(\n    x=decomp_components[:, 0],\n    y=decomp_components[:, 1],\n    hue=kmeans_clusters[4].predict(df_feature),\n    palette=sns.color_palette(\"tab10\"),\n    ax=ax,\n)\n\nplt.suptitle(\"data visualised with PCA\")\nplt.show()\n\n\n/var/folders/q6/pntlsv6s1j19xm8fhz9g32fr0000gn/T/ipykernel_28168/1685628906.py:6: UserWarning: The palette list has more values (10) than needed (6), which may not be intended.\n  sns.scatterplot(\n\n\n\n\n\n\n\n\n\n\n\nCode\ndecomp_umap = umap.UMAP(\n    n_components=2, min_dist=0.5, n_neighbors=12, n_jobs=1, random_state=92\n)\ndecomp_components_umap = decomp_umap.fit_transform(df_feature)\n\nfig, ax = plt.subplots(figsize=FIGSIZE)\n\nsns.scatterplot(\n    x=decomp_components_umap[:, 0],\n    y=decomp_components_umap[:, 1],\n    hue=kmeans_clusters[4].predict(df_feature),\n    palette=sns.color_palette(\"tab10\", 6),\n    ax=ax,\n)\n\nplt.show()"
  },
  {
    "objectID": "posts/cluster/cluster.html#analysis-and-evaluation",
    "href": "posts/cluster/cluster.html#analysis-and-evaluation",
    "title": "Cluster",
    "section": "6 Analysis and Evaluation",
    "text": "6 Analysis and Evaluation\nAnalyze each customer group‚Äôs traits, like average age or buying habits. Use metrics like Silhouette Score or Dunn Index to assess clustering quality, evaluating cluster cohesion and separation. A successful clustering result scores well on these metrics and provides actionable business insights.\n\n\nCode\ndf_cluster = df_feature.assign(cluster=kmeans_clusters[4].predict(df_feature))\ndf_mall_cluster = df_mall.assign(cluster=kmeans_clusters[4].predict(df_feature)).drop(\n    columns=[\"id\"]\n)\n\n\n\n\nCode\n#\ndf_all = pd.concat([df_mall.drop(columns=[\"id\"]), df_cluster], axis=1)\n\n\n\n\nCode\ngrouper = df_mall_cluster.groupby(\"cluster\", as_index=False)\ndf_cluster_agg = grouper.mean().round(2)\ndf_cluster_agg = df_cluster_agg.assign(\n    count=grouper.count()[\"age\"], age=(df_cluster_agg[\"age\"].astype(\"int\"))\n)\n\n\n\n\nCode\ndf_cluster_agg\n\n\n\n\n\n\n\n\n\n\ncluster\nage\nincome\nspending\ngender_male\ncount\n\n\n\n\n0\n0\n41\n89.41\n15.59\n0.56\n32\n\n\n1\n1\n26\n56.21\n49.54\n0.33\n39\n\n\n2\n2\n25\n24.30\n76.52\n0.43\n23\n\n\n3\n3\n55\n54.77\n48.23\n0.46\n48\n\n\n4\n4\n32\n86.54\n82.13\n0.46\n39\n\n\n5\n5\n46\n26.11\n17.42\n0.37\n19\n\n\n\n\n\n\n\n\n\n\nCode\nsns.boxplot(\n    df_mall_cluster,\n    y=\"cluster\",\n    x=\"age\",\n    orient=\"h\",\n    hue=\"cluster\",\n    palette=sns.color_palette(\"tab10\", 6),\n)\n\nplt.title(\"Age of each customer segment\")\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\nCode\nsns.countplot(\n    df_cluster,\n    x=\"cluster\",\n    hue=\"gender_male\",\n    stat=\"percent\",\n    palette=sns.color_palette(\"tab10\", 2),\n)\n\nplt.title(\"gender ration between the customer segments\")\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\nCode\na = 0.1\nmean_gender = df_mall[\"gender_male\"].mean()\nl_mean_gender, u_mean_gender = mean_gender * (1 - a), mean_gender * (1 + a)\n\n\n\n\nCode\n# define a mostly gender column\n# determine which cluster falls outside of the bounds\ndf_gender = df_cluster_agg[[\"cluster\", \"gender_male\"]].assign(gender=\"neutral\")\ndf_gender.loc[df_gender[\"gender_male\"].gt(u_mean_gender), \"gender\"] = \"mostly men\"\ndf_gender.loc[df_gender[\"gender_male\"].lt(l_mean_gender), \"gender\"] = \"mostly female\"\ndf_gender\n\n\n\n\n\n\n\n\n\n\ncluster\ngender_male\ngender\n\n\n\n\n0\n0\n0.56\nmostly men\n\n\n1\n1\n0.33\nmostly female\n\n\n2\n2\n0.43\nneutral\n\n\n3\n3\n0.46\nneutral\n\n\n4\n4\n0.46\nneutral\n\n\n5\n5\n0.37\nmostly female\n\n\n\n\n\n\n\n\n\n\nCode\nfig, ax = plt.subplots(1, 1, figsize=FIGSIZE)\n\ncurr_ax = ax\n_ = sns.scatterplot(\n    data=df_cluster_agg,\n    x=\"income\",\n    y=\"spending\",\n    hue=\"cluster\",\n    palette=sns.color_palette(\"tab10\", 6),\n    s=200,\n    ax=curr_ax,\n)\n\nxlim0, xlim1 = ax.get_xlim()\nylim0, ylim1 = ax.get_ylim()\n\nplt.vlines(\n    df_mall_cluster[\"income\"].median(), ylim0, ylim1, color=\"grey\", linestyles=\"--\"\n)\nplt.hlines(\n    df_mall_cluster[\"spending\"].median(),\n    xlim0,\n    xlim1,\n    color=\"grey\",\n    linestyles=\"--\",\n)\nplt.suptitle(\"Age vs. Spending\")\nplt.show()"
  },
  {
    "objectID": "posts/cluster/cluster.html#insights-and-business-applications",
    "href": "posts/cluster/cluster.html#insights-and-business-applications",
    "title": "Cluster",
    "section": "7 Insights and Business Applications",
    "text": "7 Insights and Business Applications\nExplain how the results could be used to tailor marketing strategies towards each segment for improved customer engagement and retention.\n\n\nCode\n# add the cluster labels to the dataframe\ndf_mall_cluster_centroid = df_mall_cluster.merge(\n    df_cluster_agg.drop(columns=[\"count\"]), on=\"cluster\", suffixes=(\"\", \"_cluster\")\n)\n\n\n\n\nCode\ndef create_blend(df_in: pd.DataFrame, col1: str, steps: int):\n    \"\"\"\n    Applies a function that generates a linear sequence between the value of\n    a specified column and the corresponding cluster value in each row of the dataframe.\n\n    Parameters\n    ----------\n    df_in : pd.DataFrame\n        Input dataframe with at least two columns: one specified by `col1` and another with `col1` suffix '_cluster'.\n    col1 : str\n        The name of the column in the dataframe from which to start the linear sequence.\n    steps : int\n        The number of steps in the linear sequence.\n\n    Returns\n    -------\n    pd.DataFrame\n        A dataframe with each cell containing a linear sequence between the corresponding cell in `col1` and `col1_cluster`.\n\n    \"\"\"\n    return df_in.apply(\n        lambda row: np.linspace(row[col1], row[f\"{col1}_cluster\"], steps), axis=1\n    )\n\n\n# add the blend columns to the three variables of interest\ndf_mall_cluster_centroid = df_mall_cluster_centroid.assign(\n    spending_blend=create_blend(df_mall_cluster_centroid, \"spending\", 50),\n    age_blend=create_blend(df_mall_cluster_centroid, \"age\", 50),\n    income_blend=create_blend(df_mall_cluster_centroid, \"income\", 50),\n)\ndf_mall_cluster_centroid\n\n\n\n\n\n\n\n\n\n\nage\nincome\nspending\ngender_male\ncluster\nage_cluster\nincome_cluster\nspending_cluster\ngender_male_cluster\nspending_blend\nage_blend\nincome_blend\n\n\n\n\n0\n19\n15\n39\nTrue\n2\n25\n24.30\n76.52\n0.43\n[39.0, 39.76571428571429, 40.53142857142857, 4...\n[19.0, 19.122448979591837, 19.244897959183675,...\n[15.0, 15.189795918367347, 15.379591836734694,...\n\n\n1\n21\n15\n81\nTrue\n2\n25\n24.30\n76.52\n0.43\n[81.0, 80.90857142857143, 80.81714285714285, 8...\n[21.0, 21.081632653061224, 21.163265306122447,...\n[15.0, 15.189795918367347, 15.379591836734694,...\n\n\n2\n23\n16\n77\nFalse\n2\n25\n24.30\n76.52\n0.43\n[77.0, 76.99020408163265, 76.98040816326531, 7...\n[23.0, 23.040816326530614, 23.081632653061224,...\n[16.0, 16.16938775510204, 16.33877551020408, 1...\n\n\n3\n31\n17\n40\nFalse\n2\n25\n24.30\n76.52\n0.43\n[40.0, 40.74530612244898, 41.49061224489796, 4...\n[31.0, 30.877551020408163, 30.755102040816325,...\n[17.0, 17.148979591836735, 17.29795918367347, ...\n\n\n4\n22\n17\n76\nFalse\n2\n25\n24.30\n76.52\n0.43\n[76.0, 76.01061224489796, 76.02122448979591, 7...\n[22.0, 22.06122448979592, 22.122448979591837, ...\n[17.0, 17.148979591836735, 17.29795918367347, ...\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n195\n34\n103\n23\nFalse\n0\n41\n89.41\n15.59\n0.56\n[23.0, 22.84877551020408, 22.697551020408163, ...\n[34.0, 34.142857142857146, 34.285714285714285,...\n[103.0, 102.72265306122449, 102.44530612244898...\n\n\n196\n33\n113\n8\nTrue\n0\n41\n89.41\n15.59\n0.56\n[8.0, 8.154897959183673, 8.309795918367348, 8....\n[33.0, 33.16326530612245, 33.326530612244895, ...\n[113.0, 112.51857142857143, 112.03714285714285...\n\n\n197\n47\n120\n16\nFalse\n0\n41\n89.41\n15.59\n0.56\n[16.0, 15.991632653061224, 15.98326530612245, ...\n[47.0, 46.87755102040816, 46.755102040816325, ...\n[120.0, 119.37571428571428, 118.75142857142858...\n\n\n198\n45\n126\n28\nFalse\n0\n41\n89.41\n15.59\n0.56\n[28.0, 27.746734693877553, 27.493469387755102,...\n[45.0, 44.91836734693877, 44.83673469387755, 4...\n[126.0, 125.25326530612244, 124.5065306122449,...\n\n\n199\n32\n137\n18\nTrue\n0\n41\n89.41\n15.59\n0.56\n[18.0, 17.950816326530614, 17.901632653061224,...\n[32.0, 32.183673469387756, 32.36734693877551, ...\n[137.0, 136.02877551020407, 135.05755102040817...\n\n\n\n\n200 rows √ó 12 columns\n\n\n\n\n\n\nCode\nfig, ax = plt.subplots(1, 1, figsize=FIGSIZE)\n\nsns.scatterplot(\n    x=df_mall_cluster_centroid[\"spending_blend\"].apply(lambda row: row[0]),\n    y=df_mall_cluster_centroid[\"age_blend\"].apply(lambda row: row[0]),\n    hue=df_mall_cluster_centroid[\"cluster\"],\n    palette=sns.color_palette(\"tab10\", 6),\n    s=200,\n    alpha=0.7,\n    ax=ax,\n)\n\nxlim_begin, ylim_begin = ax.get_xlim(), ax.get_ylim()\n\n###\n\nfig, ax = plt.subplots(1, 1, figsize=FIGSIZE)\n\n\nsns.scatterplot(\n    x=df_mall_cluster_centroid[\"spending_blend\"].apply(lambda row: row[-1]),\n    y=df_mall_cluster_centroid[\"age_blend\"].apply(lambda row: row[-1]),\n    hue=df_mall_cluster_centroid[\"cluster\"],\n    palette=sns.color_palette(\"tab10\", 6),\n    s=200,\n    alpha=0.7,\n    ax=ax,\n)\n\nxlim_end, ylim_end = ax.get_xlim(), ax.get_ylim()\n\nzoom_factor = 0.1\n# get the global axes limits\noveral_xlim = (\n    min(xlim_begin[0], xlim_end[0]) * (1 - zoom_factor),\n    max(xlim_begin[1], xlim_end[1]) * (1 + zoom_factor),\n)\noveral_ylim = (\n    min(ylim_begin[0], ylim_end[0]) * (1 - zoom_factor),\n    max(ylim_begin[1], ylim_end[1]) * (1 + zoom_factor),\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nfreeze_frames = 10\n# create the animation\nframes = [plot_step(i, overal_xlim, overal_ylim) for i in range(50)]\n\n# freeze on the bounce point\nframes.extend([frames[-1] for _ in range(freeze_frames // 6)])\n\n# add the the original series in reverse\nframes.extend(frames[::-1])\n\n\ngif.save(frames, \"artifacts/clumper.gif\", duration=0.05)"
  }
]